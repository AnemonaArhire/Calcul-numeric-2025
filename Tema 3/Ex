import numpy as np
from scipy.sparse import lil_matrix, csr_matrix
from scipy.sparse.linalg import norm
from scipy.linalg import solve


# ğŸ”¹ Citirea matricei rare din fiÈ™ier
def citire_matrice_rara(nume_fisier):
    try:
        with open(nume_fisier, 'r') as f:
            n = int(f.readline().strip())  # Dimensiunea matricei
            A = lil_matrix((n, n))
            for line in f:
                valori = line.strip().replace(',', ' ').split()
                if len(valori) != 3:
                    print(f"âš ï¸ Linie invalidÄƒ (ignorat): {line}")
                    continue
                try:
                    i, j, val = int(float(valori[0])), int(float(valori[1])), float(valori[2])
                    i -= 1  # AjustÄƒm indexul de la 1 la 0
                    j -= 1  # AjustÄƒm indexul de la 1 la 0
                    A[i, j] += val  # Ãn cazul Ã®n care indicii se repetÄƒ, se adunÄƒ valorile
                except ValueError as e:
                    print(f"âŒ Eroare la procesarea liniei: {line} - {e}")
                    continue
        return A.tocsr()
    except FileNotFoundError:
        print(f"âŒ Eroare: FiÈ™ierul {nume_fisier} nu a fost gÄƒsit!")
        exit(1)
    except ValueError as e:
        print(f"âŒ Eroare la citirea fiÈ™ierului {nume_fisier}: {e}")
        exit(1)

# ğŸ”¹ 2. Citirea vectorului b
def citire_vector_b(nume_fisier):
    try:
        with open(nume_fisier, 'r') as f:
            n = int(f.readline().strip())
            b = np.zeros(n)
            for i, line in enumerate(f):
                if line.strip():
                    b[i] = float(line.strip())
        return b
    except FileNotFoundError:
        print(f"âŒ Eroare: FiÈ™ierul {nume_fisier} nu a fost gÄƒsit!")
        exit(1)
    except ValueError as e:
        print(f"âŒ Eroare la citirea fiÈ™ierului {nume_fisier}: {e}")
        exit(1)


# ğŸ”¹ 3. Generare matrice rarÄƒ pe linii
def generare_matrice_rara_linii(A):
    n = A.shape[0]
    valori = []
    ind_col = []
    inceput_linii = [0] * (n + 1)

    for i in range(n):
        non_zero_cols = A[i].nonzero()[1]
        inceput_linii[i + 1] = inceput_linii[i] + len(non_zero_cols)
        for col in non_zero_cols:
            valori.append(A[i, col])
            ind_col.append(col)

    inceput_linii[-1] = len(valori)
    return np.array(valori), np.array(ind_col), np.array(inceput_linii)


# ğŸ”¹ 4. Generare matrice rarÄƒ pe diagonale
def generare_matrice_rara_diagonale(A):
    n = A.shape[0]
    diagonale = []
    diag_no = []

    for i in range(n):
        for j in range(i, n):
            if A[i, j] != 0:
                diag_no.append(j - i)
                diagonale.append(A[i, j])

    return np.array(diagonale), np.array(diag_no)


# ğŸ”¹ 5. Verificarea È™i eliminarea rÃ¢ndurilor È™i coloanelor cu zerouri pe diagonalÄƒ
def verifica_si_elimina_nule(A, b):
    mask = A.diagonal() != 0
    A_filtrata = A[mask][:, mask]  # EliminÄƒm atÃ¢t rÃ¢ndurile, cÃ¢t È™i coloanele
    b_filtrat = b[mask]
    eliminari = len(b) - len(b_filtrat)
    print(f"\nâœ… Eliminat {eliminari} rÃ¢nduri È™i coloane cu zerouri pe diagonalÄƒ.")
    return A_filtrata, b_filtrat


# ğŸ”¹ 6. Completarea diagonalei pentru evitarea Ã®mpÄƒrÈ›irii la zero
def completeaza_diagonala(A, epsilon=1e-10):
    for i in range(A.shape[0]):
        if A[i, i] == 0:
            A[i, i] = epsilon
            print(f"ğŸ”„ AdÄƒugat {epsilon} la A[{i}, {i}] pentru a evita Ã®mpÄƒrÈ›irea la zero.")
    return A


# ğŸ”¹ 7. Metoda Gauss-Seidel cu prevenirea overflow-ului È™i stabilizare numericÄƒ
def gauss_seidel(A, b, tol=1e-10, max_iter=10000):
    n = A.shape[0]
    x = np.zeros(n)
    max_value = 1e10  # Prag maxim pentru stabilizare numericÄƒ

    for k in range(max_iter):
        x_new = np.copy(x)
        for i in range(n):
            suma = 0
            for j in range(n):
                if j != i:
                    try:
                        product = A[i, j] * x_new[j]
                        if np.abs(product) > max_value:  # LimitÄƒm produsul pentru a preveni overflow
                            product = np.sign(product) * max_value
                        suma += product
                    except OverflowError:
                        raise ValueError(f"âŒ Overflow detectat la iteratia {k}, element A[{i}, {j}]!")

            if np.isinf(suma) or np.isnan(suma):
                raise ValueError(f"âŒ Eroare numericÄƒ la iteratia {k}: overflow sau NaN detectat!")

            x_new[i] = (b[i] - suma) / A[i, i]

        if np.linalg.norm(x_new - x, ord=np.inf) < tol:
            return x_new, k + 1
        x = x_new

    return x, max_iter


# ğŸ”¹ 8. Calculul normei Ax - b
def calculeaza_norma(A, x, b):
    residual = A.dot(x) - b
    return np.linalg.norm(residual, np.inf)


# ğŸ”¹ 9. AfiÈ™area matricei Ã®ntr-un format lizibil
def afiseaza_matrice_formatata(A):
    np.set_printoptions(precision=7, suppress=True, linewidth=100, threshold=10_000)
    print("\nMatricea A dupÄƒ completarea diagonalei:")
    print(A.toarray())


# ğŸ”¹ FuncÈ›ia pentru suma a douÄƒ matrici rare
def suma_matrici_rari(A, B):
    return A + B


# ğŸ”¹ Verificarea cÄƒ suma matricilor corespunde cu matricea de referinÈ›Äƒ
def verifica_suma_matrici(A, B, C, epsilon=1e-10):
    # C este matricea de referinÈ›Äƒ (aplusb.txt)
    A_plus_B = suma_matrici_rari(A, B)

    # ComparÄƒm elementele matricelor A+B È™i C
    for i in range(A.shape[0]):
        for j in range(A.shape[1]):
            val_A_B = A_plus_B[i, j]
            val_C = C[i, j]

            # DacÄƒ valoarea este aproape de zero, putem ignora diferenÈ›ele foarte mici
            if np.abs(val_A_B) < epsilon and np.abs(val_C) < epsilon:
                continue  # IgnorÄƒm elementele apropiate de zero

            # VerificÄƒm diferenÈ›a pentru elementele nenule
            if np.abs(val_A_B - val_C) >= epsilon:
                print(f"âŒ Elementul A+B[{i + 1},{j + 1}] = {val_A_B}, dar Ã®n C[{i + 1},{j + 1}] = {val_C}")
                return False
    print("âœ… Suma matricelor corespunde cu matricea de referinÈ›Äƒ!")
    return True

# ğŸ”¹ 12. MAIN - Program principal
if __name__ == "__main__":
    nume_fisier_A = "a_1.txt"
    nume_fisier_B = "b_1.txt"

    # Citire matrice rarÄƒ È™i vector
    A = citire_matrice_rara(nume_fisier_A)
    b = citire_vector_b(nume_fisier_B)

    # Verificare È™i eliminare rÃ¢nduri/coloane cu zerouri pe diagonalÄƒ
    A, b = verifica_si_elimina_nule(A, b)

    # Completare diagonalÄƒ
    A = completeaza_diagonala(A)
    afiseaza_matrice_formatata(A)

    # Generare matrice rarÄƒ pe linii
    valori, ind_col, inceput_linii = generare_matrice_rara_linii(A)
    print("\nMatricea rarÄƒ generatÄƒ pe linii:")
    print(f"Valori: {valori}")
    print(f"Indici coloanÄƒ: {ind_col}")
    print(f"Ãnceput linii: {inceput_linii}")

    # Generare matrice rarÄƒ pe diagonale
    diagonale, diag_no = generare_matrice_rara_diagonale(A)
    print("\nMatricea rarÄƒ generatÄƒ pe diagonale:")
    print(f"Diagonale: {diagonale}")
    print(f"NumÄƒr diagonale: {diag_no}")

    # AplicaÈ›ie metoda Gauss-Seidel
    try:
        x_GS, iteratii = gauss_seidel(A, b)
        print(f"\nâœ… SoluÈ›ia aproximativÄƒ x_GS: {x_GS}")
        print(f"ğŸ”„ NumÄƒr de iteraÈ›ii: {iteratii}")
        print(f"ğŸ”„ Norma ||Ax - b||âˆ: {calculeaza_norma(A, x_GS, b)}")
    except ValueError as e:
        print(f"\nâŒ Eroare Gauss-Seidel: {e}")
        print("â¡ï¸ ÃncercÄƒm eliminarea Gaussiana...")

    # BONUS: Suma a douÄƒ matrici rare
    print("\nğŸ”” BONUS - Suma a douÄƒ matrici rare:")
    nume_fisier_A = "a.txt"
    nume_fisier_B = "b.txt"
    nume_fisier_C = "aplusb.txt"  # Matricea de referinÈ›Äƒ

    # Citirea matricelor rare A È™i B È™i a matricii de referinÈ›Äƒ C
    A = citire_matrice_rara(nume_fisier_A)
    B = citire_matrice_rara(nume_fisier_B)
    C = citire_matrice_rara(nume_fisier_C)

    # VerificÄƒm dacÄƒ suma matricelor A È™i B corespunde cu matricea C
    if verifica_suma_matrici(A, B, C):
        print("âœ… Suma matricelor este corectÄƒ!")
    else:
        print("âŒ Suma matricelor nu corespunde cu matricea de referinÈ›Äƒ.")
